/**
 * CannaVille Pro - First Person Controller
 * Immersive first-person navigation with realistic physics and interactions
 */

import * as THREE from 'three';
import { gsap } from 'gsap';

export class FirstPersonController {
    constructor(engine) {
        this.engine = engine;
        this.camera = engine.camera;
        
        // Controller state
        this.isEnabled = true;
        this.isLocked = false;
        
        // Movement properties
        this.movement = {
            velocity: new THREE.Vector3(),
            direction: new THREE.Vector3(),
            speed: 5.0,
            sprintMultiplier: 2.0,
            jumpHeight: 8.0,
            gravity: -30.0,
            friction: 0.8,
            airResistance: 0.95,
            isGrounded: true,
            canJump: true
        };\n        \n        // Camera properties\n        this.camera = {\n            height: 1.8, // Eye level height\n            bobAmount: 0.05,\n            bobSpeed: 10,\n            bobPhase: 0,\n            mouseSensitivity: 0.002,\n            smoothing: 0.1,\n            minPolarAngle: 0,\n            maxPolarAngle: Math.PI,\n            euler: new THREE.Euler(0, 0, 0, 'YXZ'),\n            pitchObject: new THREE.Object3D(),\n            yawObject: new THREE.Object3D()\n        };\n        \n        // Physics properties\n        this.physics = {\n            enabled: true,\n            collisionRadius: 0.3,\n            stepHeight: 0.3,\n            groundCheckDistance: 0.1,\n            raycaster: new THREE.Raycaster(),\n            collisionObjects: []\n        };\n        \n        // Interaction properties\n        this.interaction = {\n            range: 3.0,\n            raycaster: new THREE.Raycaster(),\n            crosshair: null,\n            highlightedObject: null,\n            interactionPrompt: null\n        };\n        \n        // Input state\n        this.input = {\n            keys: {},\n            mouse: {\n                x: 0,\n                y: 0,\n                deltaX: 0,\n                deltaY: 0\n            },\n            moveForward: false,\n            moveBackward: false,\n            moveLeft: false,\n            moveRight: false,\n            sprint: false,\n            jump: false\n        };\n        \n        // Mobile support\n        this.mobile = {\n            isTouch: 'ontouchstart' in window,\n            virtualJoystick: null,\n            lookSensitivity: 0.003\n        };\n        \n        this.isInitialized = false;\n    }\n    \n    /**\n     * Initialize the first person controller\n     */\n    async init() {\n        console.log('🎮 Initializing First Person Controller...');\n        \n        try {\n            // Setup camera hierarchy\n            this.setupCameraHierarchy();\n            \n            // Setup controls\n            this.setupControls();\n            \n            // Setup physics\n            this.setupPhysics();\n            \n            // Setup interaction system\n            this.setupInteractionSystem();\n            \n            // Setup mobile controls\n            if (this.mobile.isTouch) {\n                this.setupMobileControls();\n            }\n            \n            // Start update loop\n            this.startUpdateLoop();\n            \n            this.isInitialized = true;\n            console.log('✅ First Person Controller initialized');\n            \n        } catch (error) {\n            console.error('❌ Failed to initialize First Person Controller:', error);\n            throw error;\n        }\n    }\n    \n    /**\n     * Setup camera hierarchy for first-person view\n     */\n    setupCameraHierarchy() {\n        // Create camera hierarchy: yaw -> pitch -> camera\n        this.camera.yawObject.add(this.camera.pitchObject);\n        this.camera.pitchObject.add(this.engine.camera);\n        \n        // Set initial camera position\n        this.camera.yawObject.position.set(0, this.camera.height, 5);\n        this.engine.camera.position.set(0, 0, 0);\n        \n        // Add to scene\n        this.engine.scene.add(this.camera.yawObject);\n        \n        console.log('✅ Camera hierarchy setup complete');\n    }\n    \n    /**\n     * Setup input controls\n     */\n    setupControls() {\n        // Pointer lock API\n        this.setupPointerLock();\n        \n        // Keyboard events\n        document.addEventListener('keydown', this.onKeyDown.bind(this));\n        document.addEventListener('keyup', this.onKeyUp.bind(this));\n        \n        // Mouse events\n        document.addEventListener('mousemove', this.onMouseMove.bind(this));\n        document.addEventListener('click', this.onClick.bind(this));\n        \n        // Touch events for mobile\n        document.addEventListener('touchstart', this.onTouchStart.bind(this), { passive: false });\n        document.addEventListener('touchmove', this.onTouchMove.bind(this), { passive: false });\n        document.addEventListener('touchend', this.onTouchEnd.bind(this), { passive: false });\n        \n        console.log('✅ Input controls setup complete');\n    }\n    \n    /**\n     * Setup pointer lock for mouse capture\n     */\n    setupPointerLock() {\n        const canvas = this.engine.renderer.domElement;\n        \n        // Pointer lock change events\n        document.addEventListener('pointerlockchange', () => {\n            this.isLocked = document.pointerLockElement === canvas;\n            this.updateLockStatus();\n        });\n        \n        document.addEventListener('pointerlockerror', () => {\n            console.error('Pointer lock failed');\n        });\n        \n        // Click to lock\n        canvas.addEventListener('click', () => {\n            if (!this.isLocked) {\n                canvas.requestPointerLock();\n            }\n        });\n    }\n    \n    /**\n     * Update lock status UI\n     */\n    updateLockStatus() {\n        if (this.isLocked) {\n            this.showCrosshair();\n            this.hideLockPrompt();\n        } else {\n            this.hideCrosshair();\n            this.showLockPrompt();\n        }\n    }\n    \n    /**\n     * Show crosshair\n     */\n    showCrosshair() {\n        if (!this.interaction.crosshair) {\n            this.interaction.crosshair = document.createElement('div');\n            this.interaction.crosshair.style.cssText = `\n                position: fixed;\n                top: 50%;\n                left: 50%;\n                width: 4px;\n                height: 4px;\n                background: rgba(255, 255, 255, 0.8);\n                border: 1px solid rgba(0, 0, 0, 0.5);\n                border-radius: 50%;\n                transform: translate(-50%, -50%);\n                z-index: 1000;\n                pointer-events: none;\n                box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);\n            `;\n            document.body.appendChild(this.interaction.crosshair);\n        }\n        this.interaction.crosshair.style.display = 'block';\n    }\n    \n    /**\n     * Hide crosshair\n     */\n    hideCrosshair() {\n        if (this.interaction.crosshair) {\n            this.interaction.crosshair.style.display = 'none';\n        }\n    }\n    \n    /**\n     * Show lock prompt\n     */\n    showLockPrompt() {\n        if (!this.lockPrompt) {\n            this.lockPrompt = document.createElement('div');\n            this.lockPrompt.style.cssText = `\n                position: fixed;\n                top: 50%;\n                left: 50%;\n                transform: translate(-50%, -50%);\n                background: rgba(0, 0, 0, 0.8);\n                color: white;\n                padding: 20px 30px;\n                border-radius: 10px;\n                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n                font-size: 16px;\n                text-align: center;\n                z-index: 1000;\n                backdrop-filter: blur(10px);\n                border: 1px solid rgba(255, 255, 255, 0.2);\n            `;\n            this.lockPrompt.innerHTML = `\n                <div style=\"margin-bottom: 10px; font-size: 2em;\">🎮</div>\n                <div style=\"font-weight: bold; margin-bottom: 10px;\">Click to Enter First-Person Mode</div>\n                <div style=\"font-size: 14px; opacity: 0.8;\">WASD to move • Mouse to look • E to interact</div>\n            `;\n            document.body.appendChild(this.lockPrompt);\n        }\n        this.lockPrompt.style.display = 'block';\n    }\n    \n    /**\n     * Hide lock prompt\n     */\n    hideLockPrompt() {\n        if (this.lockPrompt) {\n            this.lockPrompt.style.display = 'none';\n        }\n    }\n    \n    /**\n     * Setup physics system\n     */\n    setupPhysics() {\n        // Setup collision detection\n        this.physics.raycaster.far = this.physics.collisionRadius * 2;\n        \n        // Ground check raycaster\n        this.groundRaycaster = new THREE.Raycaster();\n        this.groundRaycaster.set(\n            new THREE.Vector3(),\n            new THREE.Vector3(0, -1, 0)\n        );\n        \n        console.log('✅ Physics system setup complete');\n    }\n    \n    /**\n     * Setup interaction system\n     */\n    setupInteractionSystem() {\n        // Interaction raycaster\n        this.interaction.raycaster.far = this.interaction.range;\n        \n        // Create interaction prompt\n        this.interaction.interactionPrompt = document.createElement('div');\n        this.interaction.interactionPrompt.style.cssText = `\n            position: fixed;\n            top: 60%;\n            left: 50%;\n            transform: translateX(-50%);\n            background: rgba(0, 0, 0, 0.8);\n            color: white;\n            padding: 10px 15px;\n            border-radius: 8px;\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n            font-size: 14px;\n            z-index: 1000;\n            display: none;\n            backdrop-filter: blur(10px);\n            border: 1px solid rgba(255, 255, 255, 0.2);\n        `;\n        document.body.appendChild(this.interaction.interactionPrompt);\n        \n        console.log('✅ Interaction system setup complete');\n    }\n    \n    /**\n     * Setup mobile controls\n     */\n    setupMobileControls() {\n        // Create virtual joystick for movement\n        this.createVirtualJoystick();\n        \n        // Create look controls\n        this.createMobileLookControls();\n        \n        console.log('✅ Mobile controls setup complete');\n    }\n    \n    /**\n     * Create virtual joystick for mobile\n     */\n    createVirtualJoystick() {\n        const joystick = document.createElement('div');\n        joystick.style.cssText = `\n            position: fixed;\n            bottom: 30px;\n            left: 30px;\n            width: 120px;\n            height: 120px;\n            background: rgba(255, 255, 255, 0.1);\n            border: 2px solid rgba(255, 255, 255, 0.3);\n            border-radius: 50%;\n            z-index: 1000;\n            backdrop-filter: blur(10px);\n        `;\n        \n        const knob = document.createElement('div');\n        knob.style.cssText = `\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            width: 50px;\n            height: 50px;\n            background: rgba(255, 255, 255, 0.8);\n            border-radius: 50%;\n            transform: translate(-50%, -50%);\n            transition: all 0.1s ease;\n        `;\n        \n        joystick.appendChild(knob);\n        document.body.appendChild(joystick);\n        \n        this.mobile.virtualJoystick = { element: joystick, knob, center: { x: 0, y: 0 }, current: { x: 0, y: 0 } };\n        \n        // Setup joystick events\n        this.setupJoystickEvents();\n    }\n    \n    /**\n     * Setup joystick events\n     */\n    setupJoystickEvents() {\n        const { element, knob } = this.mobile.virtualJoystick;\n        let isDragging = false;\n        \n        const startDrag = (clientX, clientY) => {\n            isDragging = true;\n            const rect = element.getBoundingClientRect();\n            this.mobile.virtualJoystick.center = {\n                x: rect.left + rect.width / 2,\n                y: rect.top + rect.height / 2\n            };\n        };\n        \n        const updateDrag = (clientX, clientY) => {\n            if (!isDragging) return;\n            \n            const deltaX = clientX - this.mobile.virtualJoystick.center.x;\n            const deltaY = clientY - this.mobile.virtualJoystick.center.y;\n            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n            const maxDistance = 35;\n            \n            if (distance <= maxDistance) {\n                this.mobile.virtualJoystick.current = { x: deltaX, y: deltaY };\n            } else {\n                const angle = Math.atan2(deltaY, deltaX);\n                this.mobile.virtualJoystick.current = {\n                    x: Math.cos(angle) * maxDistance,\n                    y: Math.sin(angle) * maxDistance\n                };\n            }\n            \n            knob.style.transform = `translate(${this.mobile.virtualJoystick.current.x - 25}px, ${this.mobile.virtualJoystick.current.y - 25}px)`;\n            \n            // Update movement input\n            this.updateMovementFromJoystick();\n        };\n        \n        const endDrag = () => {\n            isDragging = false;\n            this.mobile.virtualJoystick.current = { x: 0, y: 0 };\n            knob.style.transform = 'translate(-50%, -50%)';\n            this.resetMovementInput();\n        };\n        \n        // Touch events\n        element.addEventListener('touchstart', (e) => {\n            e.preventDefault();\n            const touch = e.touches[0];\n            startDrag(touch.clientX, touch.clientY);\n        });\n        \n        document.addEventListener('touchmove', (e) => {\n            if (isDragging && e.touches.length > 0) {\n                const touch = e.touches[0];\n                updateDrag(touch.clientX, touch.clientY);\n            }\n        });\n        \n        document.addEventListener('touchend', () => {\n            if (isDragging) {\n                endDrag();\n            }\n        });\n    }\n    \n    /**\n     * Update movement from joystick\n     */\n    updateMovementFromJoystick() {\n        const { x, y } = this.mobile.virtualJoystick.current;\n        const deadzone = 10;\n        \n        if (Math.abs(x) > deadzone || Math.abs(y) > deadzone) {\n            const normalizedX = x / 35;\n            const normalizedY = y / 35;\n            \n            this.input.moveForward = normalizedY < -0.3;\n            this.input.moveBackward = normalizedY > 0.3;\n            this.input.moveLeft = normalizedX < -0.3;\n            this.input.moveRight = normalizedX > 0.3;\n        } else {\n            this.resetMovementInput();\n        }\n    }\n    \n    /**\n     * Reset movement input\n     */\n    resetMovementInput() {\n        this.input.moveForward = false;\n        this.input.moveBackward = false;\n        this.input.moveLeft = false;\n        this.input.moveRight = false;\n    }\n    \n    /**\n     * Create mobile look controls\n     */\n    createMobileLookControls() {\n        const lookArea = document.createElement('div');\n        lookArea.style.cssText = `\n            position: fixed;\n            top: 0;\n            right: 0;\n            width: 60%;\n            height: 100%;\n            z-index: 999;\n            background: transparent;\n        `;\n        \n        document.body.appendChild(lookArea);\n        \n        let lastTouch = { x: 0, y: 0 };\n        \n        lookArea.addEventListener('touchstart', (e) => {\n            e.preventDefault();\n            const touch = e.touches[0];\n            lastTouch = { x: touch.clientX, y: touch.clientY };\n        });\n        \n        lookArea.addEventListener('touchmove', (e) => {\n            e.preventDefault();\n            if (e.touches.length === 1) {\n                const touch = e.touches[0];\n                const deltaX = touch.clientX - lastTouch.x;\n                const deltaY = touch.clientY - lastTouch.y;\n                \n                this.updateCameraRotation(deltaX * this.mobile.lookSensitivity, deltaY * this.mobile.lookSensitivity);\n                \n                lastTouch = { x: touch.clientX, y: touch.clientY };\n            }\n        });\n    }\n    \n    /**\n     * Event handlers\n     */\n    onKeyDown(event) {\n        if (!this.isEnabled) return;\n        \n        this.input.keys[event.code] = true;\n        \n        switch (event.code) {\n            case 'KeyW':\n            case 'ArrowUp':\n                this.input.moveForward = true;\n                break;\n            case 'KeyS':\n            case 'ArrowDown':\n                this.input.moveBackward = true;\n                break;\n            case 'KeyA':\n            case 'ArrowLeft':\n                this.input.moveLeft = true;\n                break;\n            case 'KeyD':\n            case 'ArrowRight':\n                this.input.moveRight = true;\n                break;\n            case 'ShiftLeft':\n            case 'ShiftRight':\n                this.input.sprint = true;\n                break;\n            case 'Space':\n                event.preventDefault();\n                this.input.jump = true;\n                break;\n            case 'KeyE':\n                this.handleInteraction();\n                break;\n            case 'Escape':\n                if (this.isLocked) {\n                    document.exitPointerLock();\n                }\n                break;\n        }\n    }\n    \n    onKeyUp(event) {\n        if (!this.isEnabled) return;\n        \n        this.input.keys[event.code] = false;\n        \n        switch (event.code) {\n            case 'KeyW':\n            case 'ArrowUp':\n                this.input.moveForward = false;\n                break;\n            case 'KeyS':\n            case 'ArrowDown':\n                this.input.moveBackward = false;\n                break;\n            case 'KeyA':\n            case 'ArrowLeft':\n                this.input.moveLeft = false;\n                break;\n            case 'KeyD':\n            case 'ArrowRight':\n                this.input.moveRight = false;\n                break;\n            case 'ShiftLeft':\n            case 'ShiftRight':\n                this.input.sprint = false;\n                break;\n            case 'Space':\n                this.input.jump = false;\n                break;\n        }\n    }\n    \n    onMouseMove(event) {\n        if (!this.isEnabled || !this.isLocked) return;\n        \n        const deltaX = event.movementX || 0;\n        const deltaY = event.movementY || 0;\n        \n        this.updateCameraRotation(deltaX * this.camera.mouseSensitivity, deltaY * this.camera.mouseSensitivity);\n    }\n    \n    onClick(event) {\n        if (this.isLocked) {\n            this.handleInteraction();\n        }\n    }\n    \n    onTouchStart(event) {\n        // Handled by specific touch areas\n    }\n    \n    onTouchMove(event) {\n        // Handled by specific touch areas\n    }\n    \n    onTouchEnd(event) {\n        // Handled by specific touch areas\n    }\n    \n    /**\n     * Update camera rotation\n     */\n    updateCameraRotation(deltaX, deltaY) {\n        this.camera.euler.setFromQuaternion(this.engine.camera.quaternion);\n        \n        this.camera.euler.y -= deltaX;\n        this.camera.euler.x -= deltaY;\n        \n        this.camera.euler.x = Math.max(\n            this.camera.minPolarAngle - Math.PI / 2,\n            Math.min(this.camera.maxPolarAngle - Math.PI / 2, this.camera.euler.x)\n        );\n        \n        this.camera.yawObject.rotation.y = this.camera.euler.y;\n        this.camera.pitchObject.rotation.x = this.camera.euler.x;\n    }\n    \n    /**\n     * Start update loop\n     */\n    startUpdateLoop() {\n        const update = (deltaTime) => {\n            if (this.isEnabled) {\n                this.updateMovement(deltaTime);\n                this.updatePhysics(deltaTime);\n                this.updateInteractions();\n                this.updateCameraBob(deltaTime);\n            }\n            \n            requestAnimationFrame(update);\n        };\n        \n        let lastTime = 0;\n        const animate = (currentTime) => {\n            const deltaTime = (currentTime - lastTime) * 0.001;\n            lastTime = currentTime;\n            update(deltaTime);\n            requestAnimationFrame(animate);\n        };\n        \n        animate(0);\n    }\n    \n    /**\n     * Update movement\n     */\n    updateMovement(deltaTime) {\n        if (!deltaTime) return;\n        \n        const direction = new THREE.Vector3();\n        \n        // Calculate movement direction\n        if (this.input.moveForward) direction.z -= 1;\n        if (this.input.moveBackward) direction.z += 1;\n        if (this.input.moveLeft) direction.x -= 1;\n        if (this.input.moveRight) direction.x += 1;\n        \n        // Normalize direction\n        if (direction.length() > 0) {\n            direction.normalize();\n            \n            // Apply camera rotation to movement direction\n            direction.applyQuaternion(this.camera.yawObject.quaternion);\n            \n            // Calculate speed\n            let speed = this.movement.speed;\n            if (this.input.sprint) {\n                speed *= this.movement.sprintMultiplier;\n            }\n            \n            // Apply movement\n            const velocity = direction.multiplyScalar(speed);\n            \n            // Apply friction if grounded\n            if (this.movement.isGrounded) {\n                this.movement.velocity.x = velocity.x;\n                this.movement.velocity.z = velocity.z;\n            } else {\n                // Air control\n                this.movement.velocity.x += velocity.x * 0.1;\n                this.movement.velocity.z += velocity.z * 0.1;\n            }\n        } else if (this.movement.isGrounded) {\n            // Apply friction when not moving\n            this.movement.velocity.x *= this.movement.friction;\n            this.movement.velocity.z *= this.movement.friction;\n        }\n        \n        // Handle jumping\n        if (this.input.jump && this.movement.canJump && this.movement.isGrounded) {\n            this.movement.velocity.y = this.movement.jumpHeight;\n            this.movement.isGrounded = false;\n            this.movement.canJump = false;\n            \n            // Reset jump input\n            this.input.jump = false;\n            \n            // Allow jumping again after a short delay\n            setTimeout(() => {\n                this.movement.canJump = true;\n            }, 200);\n        }\n        \n        // Apply gravity\n        if (!this.movement.isGrounded) {\n            this.movement.velocity.y += this.movement.gravity * deltaTime;\n            \n            // Apply air resistance\n            this.movement.velocity.multiplyScalar(this.movement.airResistance);\n        }\n        \n        // Apply velocity to position\n        const deltaPosition = this.movement.velocity.clone().multiplyScalar(deltaTime);\n        this.camera.yawObject.position.add(deltaPosition);\n    }\n    \n    /**\n     * Update physics\n     */\n    updatePhysics(deltaTime) {\n        if (!this.physics.enabled) return;\n        \n        // Ground check\n        this.checkGround();\n        \n        // Collision detection\n        this.checkCollisions();\n        \n        // Keep camera above ground\n        if (this.camera.yawObject.position.y < this.camera.height) {\n            this.camera.yawObject.position.y = this.camera.height;\n            this.movement.velocity.y = 0;\n            this.movement.isGrounded = true;\n        }\n    }\n    \n    /**\n     * Check ground collision\n     */\n    checkGround() {\n        const position = this.camera.yawObject.position.clone();\n        position.y += this.physics.groundCheckDistance;\n        \n        this.groundRaycaster.set(position, new THREE.Vector3(0, -1, 0));\n        \n        const intersects = this.groundRaycaster.intersectObjects(this.physics.collisionObjects, true);\n        \n        if (intersects.length > 0) {\n            const distance = intersects[0].distance - this.physics.groundCheckDistance;\n            \n            if (distance <= this.camera.height + 0.1) {\n                this.movement.isGrounded = true;\n                \n                // Adjust position to ground level\n                const groundY = intersects[0].point.y + this.camera.height;\n                if (this.camera.yawObject.position.y <= groundY) {\n                    this.camera.yawObject.position.y = groundY;\n                    this.movement.velocity.y = 0;\n                }\n            } else {\n                this.movement.isGrounded = false;\n            }\n        } else {\n            this.movement.isGrounded = false;\n        }\n    }\n    \n    /**\n     * Check collisions\n     */\n    checkCollisions() {\n        const position = this.camera.yawObject.position.clone();\n        const directions = [\n            new THREE.Vector3(1, 0, 0),   // Right\n            new THREE.Vector3(-1, 0, 0),  // Left\n            new THREE.Vector3(0, 0, 1),   // Forward\n            new THREE.Vector3(0, 0, -1)   // Backward\n        ];\n        \n        directions.forEach(direction => {\n            this.physics.raycaster.set(position, direction);\n            const intersects = this.physics.raycaster.intersectObjects(this.physics.collisionObjects, true);\n            \n            if (intersects.length > 0 && intersects[0].distance < this.physics.collisionRadius) {\n                // Push back from collision\n                const pushBack = direction.clone().multiplyScalar(-(this.physics.collisionRadius - intersects[0].distance));\n                this.camera.yawObject.position.add(pushBack);\n            }\n        });\n    }\n    \n    /**\n     * Update interactions\n     */\n    updateInteractions() {\n        if (!this.isLocked) return;\n        \n        // Cast ray from camera center\n        const cameraDirection = new THREE.Vector3();\n        this.engine.camera.getWorldDirection(cameraDirection);\n        \n        this.interaction.raycaster.set(this.engine.camera.getWorldPosition(new THREE.Vector3()), cameraDirection);\n        \n        // Get interactable objects\n        const interactableObjects = this.getInteractableObjects();\n        const intersects = this.interaction.raycaster.intersectObjects(interactableObjects, true);\n        \n        if (intersects.length > 0) {\n            const object = intersects[0].object;\n            \n            if (this.interaction.highlightedObject !== object) {\n                // Clear previous highlight\n                this.clearHighlight();\n                \n                // Highlight new object\n                this.highlightObject(object);\n                this.interaction.highlightedObject = object;\n                \n                // Show interaction prompt\n                this.showInteractionPrompt(object);\n            }\n        } else {\n            // Clear highlight and prompt\n            this.clearHighlight();\n            this.hideInteractionPrompt();\n        }\n    }\n    \n    /**\n     * Get interactable objects\n     */\n    getInteractableObjects() {\n        const objects = [];\n        \n        this.engine.scene.traverse((child) => {\n            if (child.userData && child.userData.interactable) {\n                objects.push(child);\n            }\n        });\n        \n        return objects;\n    }\n    \n    /**\n     * Highlight object\n     */\n    highlightObject(object) {\n        if (object.material) {\n            // Store original emissive\n            object.userData.originalEmissive = object.material.emissive.getHex();\n            \n            // Apply highlight\n            object.material.emissive.setHex(0x444444);\n        }\n    }\n    \n    /**\n     * Clear highlight\n     */\n    clearHighlight() {\n        if (this.interaction.highlightedObject && this.interaction.highlightedObject.material) {\n            // Restore original emissive\n            if (this.interaction.highlightedObject.userData.originalEmissive !== undefined) {\n                this.interaction.highlightedObject.material.emissive.setHex(\n                    this.interaction.highlightedObject.userData.originalEmissive\n                );\n            }\n        }\n        \n        this.interaction.highlightedObject = null;\n    }\n    \n    /**\n     * Show interaction prompt\n     */\n    showInteractionPrompt(object) {\n        const prompt = this.interaction.interactionPrompt;\n        const objectType = object.userData.type || 'object';\n        \n        let message = 'Press E to interact';\n        \n        switch (objectType) {\n            case 'plant':\n                message = '🌱 Press E to inspect plant';\n                break;\n            case 'dwc_bucket':\n                message = '🪣 Press E to check hydroponic system';\n                break;\n            case 'equipment':\n                message = '⚙️ Press E to operate equipment';\n                break;\n        }\n        \n        prompt.textContent = message;\n        prompt.style.display = 'block';\n    }\n    \n    /**\n     * Hide interaction prompt\n     */\n    hideInteractionPrompt() {\n        this.interaction.interactionPrompt.style.display = 'none';\n    }\n    \n    /**\n     * Handle interaction\n     */\n    handleInteraction() {\n        if (this.interaction.highlightedObject) {\n            const object = this.interaction.highlightedObject;\n            \n            // Dispatch interaction event\n            const event = new CustomEvent('objectInteraction', {\n                detail: {\n                    object,\n                    userData: object.userData,\n                    position: object.position,\n                    controller: this\n                }\n            });\n            \n            document.dispatchEvent(event);\n            \n            // Visual feedback\n            this.createInteractionFeedback(object.position);\n            \n            console.log('🎯 Interacted with:', object.userData);\n        }\n    }\n    \n    /**\n     * Create interaction feedback\n     */\n    createInteractionFeedback(position) {\n        // Create ripple effect\n        const rippleGeometry = new THREE.RingGeometry(0, 0.5, 16);\n        const rippleMaterial = new THREE.MeshBasicMaterial({\n            color: 0x4caf50,\n            transparent: true,\n            opacity: 0.8,\n            side: THREE.DoubleSide\n        });\n        \n        const ripple = new THREE.Mesh(rippleGeometry, rippleMaterial);\n        ripple.position.copy(position);\n        ripple.lookAt(this.engine.camera.position);\n        \n        this.engine.scene.add(ripple);\n        \n        // Animate ripple\n        gsap.to(ripple.scale, {\n            duration: 0.5,\n            x: 3,\n            y: 3,\n            z: 3,\n            ease: 'power2.out'\n        });\n        \n        gsap.to(ripple.material, {\n            duration: 0.5,\n            opacity: 0,\n            ease: 'power2.out',\n            onComplete: () => {\n                this.engine.scene.remove(ripple);\n            }\n        });\n    }\n    \n    /**\n     * Update camera bob\n     */\n    updateCameraBob(deltaTime) {\n        if (!this.movement.isGrounded) return;\n        \n        const speed = this.movement.velocity.length();\n        \n        if (speed > 0.1) {\n            this.camera.bobPhase += deltaTime * this.camera.bobSpeed * (speed / this.movement.speed);\n            \n            const bobOffset = Math.sin(this.camera.bobPhase) * this.camera.bobAmount;\n            this.engine.camera.position.y = bobOffset;\n        } else {\n            // Smooth return to center\n            this.camera.bobPhase = 0;\n            this.engine.camera.position.y = THREE.MathUtils.lerp(\n                this.engine.camera.position.y,\n                0,\n                deltaTime * 5\n            );\n        }\n    }\n    \n    /**\n     * Add collision object\n     */\n    addCollisionObject(object) {\n        this.physics.collisionObjects.push(object);\n    }\n    \n    /**\n     * Remove collision object\n     */\n    removeCollisionObject(object) {\n        const index = this.physics.collisionObjects.indexOf(object);\n        if (index > -1) {\n            this.physics.collisionObjects.splice(index, 1);\n        }\n    }\n    \n    /**\n     * Set position\n     */\n    setPosition(x, y, z) {\n        this.camera.yawObject.position.set(x, y, z);\n        this.movement.velocity.set(0, 0, 0);\n    }\n    \n    /**\n     * Get position\n     */\n    getPosition() {\n        return this.camera.yawObject.position.clone();\n    }\n    \n    /**\n     * Enable/disable controller\n     */\n    setEnabled(enabled) {\n        this.isEnabled = enabled;\n        \n        if (!enabled) {\n            this.resetMovementInput();\n            this.movement.velocity.set(0, 0, 0);\n        }\n    }\n    \n    /**\n     * Dispose of controller\n     */\n    dispose() {\n        // Remove event listeners\n        document.removeEventListener('keydown', this.onKeyDown);\n        document.removeEventListener('keyup', this.onKeyUp);\n        document.removeEventListener('mousemove', this.onMouseMove);\n        document.removeEventListener('click', this.onClick);\n        \n        // Remove UI elements\n        if (this.interaction.crosshair) {\n            this.interaction.crosshair.remove();\n        }\n        \n        if (this.lockPrompt) {\n            this.lockPrompt.remove();\n        }\n        \n        if (this.interaction.interactionPrompt) {\n            this.interaction.interactionPrompt.remove();\n        }\n        \n        if (this.mobile.virtualJoystick) {\n            this.mobile.virtualJoystick.element.remove();\n        }\n        \n        // Clear highlights\n        this.clearHighlight();\n    }\n}

