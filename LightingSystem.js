/**
 * CannaVille Pro - Advanced Lighting System
 * Hyper-realistic lighting with dynamic shadows and volumetric effects
 */

import * as THREE from 'three';

export class LightingSystem {
    constructor(engine) {
        this.engine = engine;
        this.lights = new Map();
        this.shadows = new Map();
        this.volumetricLights = new Map();
        
        // Lighting configurations
        this.lightingConfigs = {
            indoor: {
                ambient: { color: 0x404040, intensity: 0.2 },
                sun: { color: 0xffffff, intensity: 0.3, position: [10, 20, 5] },
                growLights: [
                    { 
                        type: 'led_panel',
                        color: 0xff1493,
                        intensity: 2.0,
                        position: [-2, 6, 0],
                        size: [1.2, 0.6],
                        spectrum: 'full_spectrum'
                    },
                    { 
                        type: 'led_panel',
                        color: 0xff1493,
                        intensity: 2.0,
                        position: [2, 6, 0],
                        size: [1.2, 0.6],
                        spectrum: 'full_spectrum'
                    }
                ]
            },
            outdoor: {
                ambient: { color: 0x87CEEB, intensity: 0.4 },
                sun: { color: 0xffffff, intensity: 1.2, position: [50, 100, 20] },
                growLights: []
            }
        };
        
        // Time of day settings
        this.timeOfDay = 0.5; // 0 = midnight, 0.5 = noon, 1 = midnight
        this.dayDuration = 120; // seconds
        
        this.isInitialized = false;
    }
    
    /**
     * Initialize the lighting system
     */
    async init() {
        console.log('💡 Initializing Advanced Lighting System...');
        
        try {
            // Setup shadow mapping
            this.setupShadowMapping();
            
            // Create lighting for both environments
            this.createIndoorLighting();
            this.createOutdoorLighting();
            
            // Setup volumetric lighting
            this.setupVolumetricLighting();
            
            // Setup dynamic lighting controls
            this.setupDynamicLighting();
            
            // Start lighting update loop
            this.startLightingLoop();
            
            this.isInitialized = true;
            console.log('✅ Advanced Lighting System initialized');
            
        } catch (error) {
            console.error('❌ Failed to initialize Lighting System:', error);
            throw error;
        }
    }
    
    /**
     * Setup shadow mapping for realistic shadows
     */
    setupShadowMapping() {
        // Enable shadows on renderer
        this.engine.renderer.shadowMap.enabled = true;
        this.engine.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.engine.renderer.shadowMap.autoUpdate = true;
        
        // Shadow camera settings
        this.shadowCameraSettings = {\n            near: 0.1,\n            far: 100,\n            left: -20,\n            right: 20,\n            top: 20,\n            bottom: -20,\n            mapSize: 2048\n        };\n        \n        console.log('✅ Shadow mapping configured');\n    }\n    \n    /**\n     * Create indoor lighting setup\n     */\n    createIndoorLighting() {\n        const indoorLights = new THREE.Group();\n        indoorLights.name = 'IndoorLighting';\n        \n        const config = this.lightingConfigs.indoor;\n        \n        // Ambient light\n        const ambientLight = new THREE.AmbientLight(\n            config.ambient.color,\n            config.ambient.intensity\n        );\n        ambientLight.name = 'IndoorAmbient';\n        indoorLights.add(ambientLight);\n        \n        // Directional light (sun through windows)\n        const sunLight = new THREE.DirectionalLight(\n            config.sun.color,\n            config.sun.intensity\n        );\n        sunLight.position.set(...config.sun.position);\n        sunLight.castShadow = true;\n        \n        // Configure shadow camera\n        sunLight.shadow.camera.near = this.shadowCameraSettings.near;\n        sunLight.shadow.camera.far = this.shadowCameraSettings.far;\n        sunLight.shadow.camera.left = this.shadowCameraSettings.left;\n        sunLight.shadow.camera.right = this.shadowCameraSettings.right;\n        sunLight.shadow.camera.top = this.shadowCameraSettings.top;\n        sunLight.shadow.camera.bottom = this.shadowCameraSettings.bottom;\n        sunLight.shadow.mapSize.width = this.shadowCameraSettings.mapSize;\n        sunLight.shadow.mapSize.height = this.shadowCameraSettings.mapSize;\n        sunLight.shadow.bias = -0.0001;\n        \n        sunLight.name = 'IndoorSun';\n        indoorLights.add(sunLight);\n        \n        // LED grow lights\n        config.growLights.forEach((lightConfig, index) => {\n            const growLight = this.createLEDGrowLight(lightConfig, index);\n            indoorLights.add(growLight);\n        });\n        \n        // Add helper lights for better illumination\n        const fillLight1 = new THREE.PointLight(0x4169e1, 0.3, 10);\n        fillLight1.position.set(-3, 4, 3);\n        fillLight1.name = 'IndoorFill1';\n        indoorLights.add(fillLight1);\n        \n        const fillLight2 = new THREE.PointLight(0x4169e1, 0.3, 10);\n        fillLight2.position.set(3, 4, -3);\n        fillLight2.name = 'IndoorFill2';\n        indoorLights.add(fillLight2);\n        \n        this.lights.set('indoor', indoorLights);\n        console.log('✅ Created indoor lighting');\n    }\n    \n    /**\n     * Create LED grow light\n     */\n    createLEDGrowLight(config, index) {\n        const growLightGroup = new THREE.Group();\n        growLightGroup.name = `GrowLight_${index}`;\n        \n        // Main grow light\n        const growLight = new THREE.RectAreaLight(\n            config.color,\n            config.intensity,\n            config.size[0],\n            config.size[1]\n        );\n        \n        growLight.position.set(...config.position);\n        growLight.lookAt(0, 0, 0);\n        growLight.castShadow = false; // RectAreaLight doesn't support shadows\n        \n        growLightGroup.add(growLight);\n        \n        // Add point lights for shadow casting\n        const shadowLight = new THREE.PointLight(\n            config.color,\n            config.intensity * 0.5,\n            8\n        );\n        shadowLight.position.copy(growLight.position);\n        shadowLight.castShadow = true;\n        shadowLight.shadow.mapSize.width = 1024;\n        shadowLight.shadow.mapSize.height = 1024;\n        shadowLight.shadow.camera.near = 0.1;\n        shadowLight.shadow.camera.far = 10;\n        shadowLight.shadow.bias = -0.0001;\n        \n        growLightGroup.add(shadowLight);\n        \n        // Create volumetric light effect\n        const volumetricGeometry = new THREE.ConeGeometry(2, 6, 8, 1, true);\n        const volumetricMaterial = new THREE.MeshBasicMaterial({\n            color: config.color,\n            transparent: true,\n            opacity: 0.1,\n            side: THREE.DoubleSide,\n            depthWrite: false\n        });\n        \n        const volumetricCone = new THREE.Mesh(volumetricGeometry, volumetricMaterial);\n        volumetricCone.position.copy(growLight.position);\n        volumetricCone.position.y -= 3;\n        volumetricCone.rotation.x = Math.PI;\n        \n        growLightGroup.add(volumetricCone);\n        \n        // Store volumetric light for animation\n        this.volumetricLights.set(`grow_${index}`, volumetricCone);\n        \n        return growLightGroup;\n    }\n    \n    /**\n     * Create outdoor lighting setup\n     */\n    createOutdoorLighting() {\n        const outdoorLights = new THREE.Group();\n        outdoorLights.name = 'OutdoorLighting';\n        \n        const config = this.lightingConfigs.outdoor;\n        \n        // Ambient light (sky)\n        const ambientLight = new THREE.AmbientLight(\n            config.ambient.color,\n            config.ambient.intensity\n        );\n        ambientLight.name = 'OutdoorAmbient';\n        outdoorLights.add(ambientLight);\n        \n        // Directional light (sun)\n        const sunLight = new THREE.DirectionalLight(\n            config.sun.color,\n            config.sun.intensity\n        );\n        sunLight.position.set(...config.sun.position);\n        sunLight.castShadow = true;\n        \n        // Configure shadow camera for outdoor scene\n        sunLight.shadow.camera.near = 1;\n        sunLight.shadow.camera.far = 200;\n        sunLight.shadow.camera.left = -50;\n        sunLight.shadow.camera.right = 50;\n        sunLight.shadow.camera.top = 50;\n        sunLight.shadow.camera.bottom = -50;\n        sunLight.shadow.mapSize.width = 4096;\n        sunLight.shadow.mapSize.height = 4096;\n        sunLight.shadow.bias = -0.0001;\n        \n        sunLight.name = 'OutdoorSun';\n        outdoorLights.add(sunLight);\n        \n        // Hemisphere light for sky illumination\n        const hemisphereLight = new THREE.HemisphereLight(\n            0x87CEEB, // Sky color\n            0x8b4513, // Ground color\n            0.3\n        );\n        hemisphereLight.name = 'OutdoorHemisphere';\n        outdoorLights.add(hemisphereLight);\n        \n        // Add atmospheric scattering effect\n        const atmosphereGeometry = new THREE.SphereGeometry(100, 32, 16);\n        const atmosphereMaterial = new THREE.ShaderMaterial({\n            uniforms: {\n                time: { value: 0 },\n                sunPosition: { value: new THREE.Vector3(...config.sun.position) },\n                rayleighCoefficient: { value: 0.0025 },\n                mieCoefficient: { value: 0.0010 },\n                sunIntensity: { value: 1000 }\n            },\n            vertexShader: `\n                varying vec3 vWorldPosition;\n                void main() {\n                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n                    vWorldPosition = worldPosition.xyz;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }\n            `,\n            fragmentShader: `\n                uniform float time;\n                uniform vec3 sunPosition;\n                uniform float rayleighCoefficient;\n                uniform float mieCoefficient;\n                uniform float sunIntensity;\n                \n                varying vec3 vWorldPosition;\n                \n                void main() {\n                    vec3 direction = normalize(vWorldPosition - cameraPosition);\n                    vec3 sunDirection = normalize(sunPosition);\n                    \n                    float sunDot = dot(direction, sunDirection);\n                    \n                    // Simple atmospheric scattering approximation\n                    vec3 skyColor = vec3(0.5, 0.7, 1.0);\n                    vec3 sunColor = vec3(1.0, 0.9, 0.7);\n                    \n                    float atmosphere = pow(1.0 - abs(direction.y), 2.0);\n                    vec3 scatter = mix(skyColor, sunColor, pow(max(sunDot, 0.0), 8.0));\n                    \n                    gl_FragColor = vec4(scatter * atmosphere, atmosphere * 0.8);\n                }\n            `,\n            side: THREE.BackSide,\n            transparent: true,\n            depthWrite: false\n        });\n        \n        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);\n        atmosphere.name = 'Atmosphere';\n        outdoorLights.add(atmosphere);\n        \n        this.lights.set('outdoor', outdoorLights);\n        console.log('✅ Created outdoor lighting');\n    }\n    \n    /**\n     * Setup volumetric lighting effects\n     */\n    setupVolumetricLighting() {\n        // Create volumetric light shafts\n        this.volumetricShader = {\n            uniforms: {\n                tDiffuse: { value: null },\n                lightPosition: { value: new THREE.Vector2(0.5, 0.5) },\n                exposure: { value: 0.18 },\n                decay: { value: 0.95 },\n                density: { value: 0.8 },\n                weight: { value: 0.4 },\n                samples: { value: 50 }\n            },\n            \n            vertexShader: `\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }\n            `,\n            \n            fragmentShader: `\n                uniform sampler2D tDiffuse;\n                uniform vec2 lightPosition;\n                uniform float exposure;\n                uniform float decay;\n                uniform float density;\n                uniform float weight;\n                uniform int samples;\n                \n                varying vec2 vUv;\n                \n                void main() {\n                    vec2 deltaTextCoord = vec2(vUv - lightPosition);\n                    vec2 textCoo = vUv;\n                    deltaTextCoord *= 1.0 / float(samples) * density;\n                    \n                    float illuminationDecay = 1.0;\n                    vec4 color = texture2D(tDiffuse, textCoo);\n                    \n                    for (int i = 0; i < samples; i++) {\n                        textCoo -= deltaTextCoord;\n                        vec4 sample = texture2D(tDiffuse, textCoo);\n                        sample *= illuminationDecay * weight;\n                        color += sample;\n                        illuminationDecay *= decay;\n                    }\n                    \n                    gl_FragColor = color * exposure;\n                }\n            `\n        };\n        \n        console.log('✅ Volumetric lighting configured');\n    }\n    \n    /**\n     * Setup dynamic lighting controls\n     */\n    setupDynamicLighting() {\n        // Light intensity controls\n        this.lightControls = {\n            growLightIntensity: 1.0,\n            ambientIntensity: 1.0,\n            sunIntensity: 1.0,\n            colorTemperature: 6500 // Kelvin\n        };\n        \n        // Light spectrum presets for grow lights\n        this.spectrumPresets = {\n            vegetative: { r: 0.3, g: 0.7, b: 1.0 }, // Blue-heavy\n            flowering: { r: 1.0, g: 0.5, b: 0.3 },  // Red-heavy\n            full_spectrum: { r: 1.0, g: 0.6, b: 0.9 } // Balanced\n        };\n        \n        console.log('✅ Dynamic lighting controls configured');\n    }\n    \n    /**\n     * Start lighting update loop\n     */\n    startLightingLoop() {\n        const updateLighting = () => {\n            this.updateDayNightCycle();\n            this.updateVolumetricEffects();\n            this.updateGrowLights();\n            \n            requestAnimationFrame(updateLighting);\n        };\n        \n        updateLighting();\n    }\n    \n    /**\n     * Update day/night cycle\n     */\n    updateDayNightCycle() {\n        const time = (Date.now() * 0.001) / this.dayDuration;\n        this.timeOfDay = (time % 1);\n        \n        // Calculate sun position\n        const sunAngle = this.timeOfDay * Math.PI * 2;\n        const sunHeight = Math.sin(sunAngle);\n        const sunX = Math.cos(sunAngle) * 50;\n        const sunY = Math.max(5, sunHeight * 50 + 10);\n        const sunZ = 20;\n        \n        // Update outdoor sun\n        const outdoorLights = this.lights.get('outdoor');\n        if (outdoorLights) {\n            const sun = outdoorLights.getObjectByName('OutdoorSun');\n            if (sun) {\n                sun.position.set(sunX, sunY, sunZ);\n                \n                // Adjust intensity based on time of day\n                const intensity = Math.max(0.1, sunHeight * 1.2);\n                sun.intensity = intensity;\n                \n                // Adjust color temperature\n                const colorTemp = this.calculateSunColor(sunHeight);\n                sun.color.copy(colorTemp);\n            }\n            \n            // Update atmosphere\n            const atmosphere = outdoorLights.getObjectByName('Atmosphere');\n            if (atmosphere && atmosphere.material.uniforms) {\n                atmosphere.material.uniforms.sunPosition.value.set(sunX, sunY, sunZ);\n                atmosphere.material.uniforms.time.value = time;\n            }\n        }\n        \n        // Update indoor lighting based on time of day\n        const indoorLights = this.lights.get('indoor');\n        if (indoorLights) {\n            const sun = indoorLights.getObjectByName('IndoorSun');\n            if (sun) {\n                // Indoor sun is dimmer and more filtered\n                const intensity = Math.max(0.05, sunHeight * 0.3);\n                sun.intensity = intensity;\n                \n                const colorTemp = this.calculateSunColor(sunHeight);\n                sun.color.copy(colorTemp);\n            }\n        }\n    }\n    \n    /**\n     * Calculate sun color based on height\n     */\n    calculateSunColor(sunHeight) {\n        if (sunHeight > 0.8) {\n            // High noon - white\n            return new THREE.Color(1.0, 1.0, 1.0);\n        } else if (sunHeight > 0.3) {\n            // Day - warm white\n            return new THREE.Color(1.0, 0.95, 0.8);\n        } else if (sunHeight > 0) {\n            // Sunrise/sunset - orange\n            return new THREE.Color(1.0, 0.6, 0.3);\n        } else {\n            // Night - blue\n            return new THREE.Color(0.3, 0.4, 0.8);\n        }\n    }\n    \n    /**\n     * Update volumetric effects\n     */\n    updateVolumetricEffects() {\n        const time = performance.now() * 0.001;\n        \n        // Animate volumetric grow lights\n        for (const [id, volumetricLight] of this.volumetricLights) {\n            if (volumetricLight.material) {\n                // Subtle opacity animation\n                const baseOpacity = 0.1;\n                const variation = Math.sin(time * 2 + parseFloat(id.split('_')[1]) * 0.5) * 0.02;\n                volumetricLight.material.opacity = baseOpacity + variation;\n            }\n        }\n    }\n    \n    /**\n     * Update grow lights\n     */\n    updateGrowLights() {\n        const indoorLights = this.lights.get('indoor');\n        if (!indoorLights) return;\n        \n        // Update grow light intensity based on controls\n        for (let i = 0; i < 2; i++) {\n            const growLight = indoorLights.getObjectByName(`GrowLight_${i}`);\n            if (growLight) {\n                growLight.traverse((child) => {\n                    if (child.isRectAreaLight || child.isPointLight) {\n                        child.intensity = child.userData.baseIntensity * this.lightControls.growLightIntensity;\n                    }\n                });\n            }\n        }\n    }\n    \n    /**\n     * Load lighting for specific environment\n     */\n    loadEnvironmentLighting(environmentType) {\n        console.log(`💡 Loading ${environmentType} lighting...`);\n        \n        // Remove current lighting\n        this.engine.scene.traverse((child) => {\n            if (child.name && (child.name.includes('Indoor') || child.name.includes('Outdoor') || child.name === 'Atmosphere')) {\n                this.engine.scene.remove(child);\n            }\n        });\n        \n        // Add new lighting\n        const lights = this.lights.get(environmentType);\n        if (lights) {\n            this.engine.scene.add(lights);\n            console.log(`✅ Loaded ${environmentType} lighting`);\n        }\n    }\n    \n    /**\n     * Update grow light spectrum\n     */\n    updateGrowLightSpectrum(spectrum) {\n        const preset = this.spectrumPresets[spectrum];\n        if (!preset) return;\n        \n        const indoorLights = this.lights.get('indoor');\n        if (!indoorLights) return;\n        \n        for (let i = 0; i < 2; i++) {\n            const growLight = indoorLights.getObjectByName(`GrowLight_${i}`);\n            if (growLight) {\n                growLight.traverse((child) => {\n                    if (child.isRectAreaLight || child.isPointLight) {\n                        child.color.setRGB(preset.r, preset.g, preset.b);\n                    }\n                });\n                \n                // Update volumetric light color\n                const volumetricLight = this.volumetricLights.get(`grow_${i}`);\n                if (volumetricLight && volumetricLight.material) {\n                    volumetricLight.material.color.setRGB(preset.r, preset.g, preset.b);\n                }\n            }\n        }\n        \n        console.log(`🌈 Updated grow light spectrum to: ${spectrum}`);\n    }\n    \n    /**\n     * Update light intensity\n     */\n    updateLightIntensity(lightType, intensity) {\n        this.lightControls[lightType + 'Intensity'] = intensity;\n        \n        if (lightType === 'growLight') {\n            this.updateGrowLights();\n        }\n    }\n    \n    /**\n     * Get current lighting state\n     */\n    getLightingState() {\n        return {\n            timeOfDay: this.timeOfDay,\n            lightControls: { ...this.lightControls },\n            activeEnvironment: this.activeEnvironment\n        };\n    }\n    \n    /**\n     * Create light helper for debugging\n     */\n    createLightHelper(lightName) {\n        const light = this.engine.scene.getObjectByName(lightName);\n        if (!light) return null;\n        \n        let helper;\n        if (light.isDirectionalLight) {\n            helper = new THREE.DirectionalLightHelper(light, 5);\n        } else if (light.isPointLight) {\n            helper = new THREE.PointLightHelper(light, 1);\n        } else if (light.isSpotLight) {\n            helper = new THREE.SpotLightHelper(light);\n        }\n        \n        if (helper) {\n            this.engine.scene.add(helper);\n            return helper;\n        }\n        \n        return null;\n    }\n    \n    /**\n     * Dispose of lighting system\n     */\n    dispose() {\n        // Clean up lights\n        for (const [name, lightGroup] of this.lights) {\n            lightGroup.traverse((child) => {\n                if (child.dispose) {\n                    child.dispose();\n                }\n            });\n        }\n        \n        this.lights.clear();\n        this.shadows.clear();\n        this.volumetricLights.clear();\n    }\n}

